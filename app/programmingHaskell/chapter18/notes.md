# Chapter 18 - Monad

## 18.1 - Monad

- A _monad_ is an _applicative functor_ with an extra feature that makes them different from and more powerful than either `<*>` or `fmap` alone.


## 18.2 - `Monad` typeclass and operations

- The `Monad` typeclass is defined as:

    ```haskell
    class Applicative m => Monad m where
        (>>=)  :: m a -> (a -> m b) -> m b
        (>>)   :: m a -> m b -> m b
        return :: a -> m a
    ```

- The `Applicative m` typeclass constraint means that you can derive `Functor` and `Applicative` in terms of `Monad`, just as you can derive `Functor` in terms of `Applicative`.

    ```haskell
    fmap f xs = xs >>= return . f

    > fmap (+1) [1..3]
    [2, 3, 4]

    > [1..3] >>= return . (+1)
    [2, 3, 4]
    ```

- Easiest operation in `Monad` is `return :: a -> m a`, which is Monad's version of `pure`.

- `(>>) :: m a -> m b -> m b` sequences two actions while discarding the resulting value of the first (i.e. the `m a`).

- `(>>=) :: m a -> (a -> m b) -> m b` is called 'bind', and it contains the things that are special about `Monad`.

- Compare the various signatures of `<$>`, `<*>` and `>>=`, and `flip (>>=)` (easier to see the similarity):

    ```haskell
    fmap       :: Functor f     =>   (a -> b) -> f a -> f b
    <*>        :: Applicative f => f (a -> b) -> f a -> f b
    flip (>>=) :: Monad f       =>   a -> f b -> f a -> f b

    >>=        :: Monad f       => f a        -> (a -> f b)
    ```

- Unlike `fmap`, which takes an `a -> b` as the 'mapping' function, bind takes an `a -> f b`.  Consider what happens if we use `fmap` with a mapping function that 'adds' extra structure:

    ```haskell
    andOne :: Int -> [Int]
    andOne x = [x, 1]

    > andOne 10
    [10, 1]

    > fmap andOne [4, 5, 6]
    [[4, 1], [5, 1], [6, 1]]

    > :t fmap andOne [4, 5, 6]
    fmap andOne [4, 5, 6] :: [[Int]]
    ```

- See how we have an extra layer of monadic structure, which has been generated by our mapping function:
    - In this case, a list of lists.
    - If we just want a single layer (`[Int]`) we need to remove the extra layer of structure.

- For lists, we can remove using `concat`:

    ```haskell
    > :t concat
    concat :: Foldable t => t [a] -> [a]

    > concat $ fmap andOne [4, 5, 6]
    [4, 1, 5, 1, 6, 1]
    ```

- `Monad` is like a generalisation of `concat`, with the unique part being the `join` function from `Control.Monad`:

    ```haskell
    > import Control.Monad
    > :t join
    join :: Monad m => m (m a) -> m a
    ```

- So, bind is a combination of the mapping function (which adds structure), and `join`, which takes it back away again:

    ```haskell
    -- This is actually flip (>>=)
    bind :: Monad m => (a -> m b) -> m a -> m b
    bind f x = join $ fmap f x
    ```
