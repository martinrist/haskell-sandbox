# Chapter 18 - Monad

## 18.1 - Monad

- A _monad_ is an _applicative functor_ with an extra feature that makes them different from and more powerful than either `<*>` or `fmap` alone.


## 18.2 - `Monad` typeclass and operations

- The `Monad` typeclass is defined as:

    ```haskell
    class Applicative m => Monad m where
        (>>=)  :: m a -> (a -> m b) -> m b
        (>>)   :: m a -> m b -> m b
        return :: a -> m a
    ```

- The `Applicative m` typeclass constraint means that you can derive `Functor` and `Applicative` in terms of `Monad`, just as you can derive `Functor` in terms of `Applicative`.

    ```haskell
    fmap f xs = xs >>= return . f

    > fmap (+1) [1..3]
    [2, 3, 4]

    > [1..3] >>= return . (+1)
    [2, 3, 4]
    ```

- Easiest operation in `Monad` is `return :: a -> m a`, which is Monad's version of `pure`.

- `(>>) :: m a -> m b -> m b` sequences two actions while discarding the resulting value of the first (i.e. the `m a`).

- `(>>=) :: m a -> (a -> m b) -> m b` is called 'bind', and it contains the things that are special about `Monad`.

- Compare the various signatures of `<$>`, `<*>` and `>>=`, and `flip (>>=)` (easier to see the similarity):

    ```haskell
    fmap       :: Functor f     =>   (a -> b) -> f a -> f b
    <*>        :: Applicative f => f (a -> b) -> f a -> f b
    flip (>>=) :: Monad f       =>   a -> f b -> f a -> f b

    >>=        :: Monad f       => f a        -> (a -> f b)
    ```

- Unlike `fmap`, which takes an `a -> b` as the 'mapping' function, bind takes an `a -> f b`.  Consider what happens if we use `fmap` with a mapping function that 'adds' extra structure:

    ```haskell
    andOne :: Int -> [Int]
    andOne x = [x, 1]

    > andOne 10
    [10, 1]

    > fmap andOne [4, 5, 6]
    [[4, 1], [5, 1], [6, 1]]

    > :t fmap andOne [4, 5, 6]
    fmap andOne [4, 5, 6] :: [[Int]]
    ```

- See how we have an extra layer of monadic structure, which has been generated by our mapping function:
    - In this case, a list of lists.
    - If we just want a single layer (`[Int]`) we need to remove the extra layer of structure.

- For lists, we can remove using `concat`:

    ```haskell
    > :t concat
    concat :: Foldable t => t [a] -> [a]

    > concat $ fmap andOne [4, 5, 6]
    [4, 1, 5, 1, 6, 1]
    ```

- `Monad` is like a generalisation of `concat`, with the unique part being the `join` function from `Control.Monad`:

    ```haskell
    > import Control.Monad
    > :t join
    join :: Monad m => m (m a) -> m a
    ```

- So, bind is a combination of the mapping function (which adds structure), and `join`, which takes it back away again:

    ```haskell
    -- This is actually flip (>>=)
    bind :: Monad m => (a -> m b) -> m a -> m b
    bind f x = join $ fmap f x
    ```

## 18.3 - `do` Syntax and Monads

- We've seen `do` syntax earlier, when sequencing operations within the `IO` monad:

    ```haskell
    sequencing :: IO ()
    sequencing = do
        putStrLn "blah"
        putStrLn "another thing"
    ```

- Consider the following 'sequencing' functions which are used in desugaring `do`:

    ```haskell
    (*>) :: Applicative f => f a -> f b -> f b
    (>>) :: Monad m       => m a -> m b -> m b
    ```

- The intial `do` syntax can be desugared using both `>>` and `*>`, both of which give the same result:

    ```haskell
    sequencing' :: IO ()
    sequencing' =
        putStrLn "blah" >>
        putStrLn "another thing"

    sequencing'' :: IO ()
    sequencing'' =
        putStrLn "blah" *>
        putStrLn "another thing"
    ```

- The alternative form of `do` syntax uses variable binding, which can be desugared using `>>=`:

    ```haskell
    binding :: IO ()
    binding = do
        name <- getLine
        putStrLn name

    binding' :: IO ()
    binding = getLine >>= putStrLn
    ```

- Consider how the types fit together in the above - see how the flipped arguments in `>>=` help the sequencing:

    ```haskell
    (>>=)    :: Monad m => m  a      -> (a      -> m  b) -> m  b
                           |  |          |         |  |     |  |
    getLine  ::            IO String     |         |  |     |  |
    putStrLn ::                          String -> IO ()    |  |
    binding  ::                                             IO ()
    ```

- Consider why we can't just `fmap` `putStrLn` over `geLine` in the above:

    ```haskell
    > putStrLn <$> getLine
    foo
    -- No output above...

    > :t (putStrLn <$> getLine)
    (putStrLn <$> getLine) :: IO (IO ())
    ```

- Since `putStrLn` has type `String -> IO ()`, using `fmap` has put an extra level of `IO` in the result, which is why it doesn't work.  We can make this work using `join`, or `>>=`:

    ```haskell
    import Control.Monad (join)
    > join $ putStrLn <$> getLine
    foo
    foo

    -- Note the argument flipping again
    > getLine >>= putStrLn
    foo
    foo
    ```

- Here, `join` has merged the effects of `getLine` and `putStrLn` into a single `IO` action.
